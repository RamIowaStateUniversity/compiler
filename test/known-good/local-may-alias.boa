m: output collection[string][int] of string;
mt: output collection[int] of string;
p: Project = input;

type T= {gen : string, kill : string};
type T1= {in : set of set of string, out : set of set of string};
cfg : CFG;
method_name : string;
project_name : string;
file_name : string;
t_ttime0 : int;

tottime := 0;
t_ttime : int;
t_ttime1 : int;
t_ttime2 : int;
t_ttime3 : int;
no_fixp := 0;
pcount := 0;

#initial phase that initializes output value for each node. initially all variables only alias themselves.
initPhase := traversal(node: CFGNode) : T {
	# lhs and rhs of nodes that has definition statements
	cur_val : T = {"", ""};
	if(node.defVariables!="")
		cur_val.kill = node.defVariables;
	if(def(node.expr)) {
		if(node.expr.kind == ExpressionKind.VARDECL || node.expr.kind == ExpressionKind.ASSIGN) {
			if(def(node.rhs)) {
				if(node.rhs.kind == ExpressionKind.VARACCESS) {
					cur_val.gen = node.rhs.variable;
				}
			}
		}
	}
	#mt["gen"][node.id] << cur_val.gen;
	#mt["kill"][node.id] << cur_val.kill;
	return cur_val;
};

#analysis phase
analysisPhase := traversal(node: CFGNode) : T1 {
	no_fixp = no_fixp + 1;
	inset : set of set of string;
	outset : set of set of string;
	cur_val : T1 = {inset, outset};
	if(def(getValue(node))) {
		cur_val = getValue(node);
	}	
	preds := node.predecessors;
	foreach(pred_node:CFGNode=preds) {	
		pred := getValue(pred_node);
		if(def(pred))
			cur_val.in = union1(cur_val.in, pred.out);
	}
	cur_val.out = setClone(cur_val.in);
	genkill := getValue(node, initPhase);
	if(genkill.kill != "") {
		foreach(tmp:set of string=cur_val.in) {
			if(contains(tmp, genkill.kill)) {
				tmp2:=setClone(tmp);
				remove(cur_val.out, tmp2);
				remove(tmp2, genkill.kill);
				if(len(tmp2)!=0) {
					add(cur_val.out, tmp2);
				}
			}
		}
		if(genkill.gen != "") {
			flag := false;
			tmpSet := setClone(cur_val.out);
			foreach(tmp:set of string=tmpSet) {
				if(contains(tmp, genkill.gen)) {
					tmp3:=setClone(tmp);
					flag = true;
					remove(cur_val.out, tmp3);
					add(tmp3, genkill.kill);
					add(cur_val.out, tmp3);
				}
			}
			if(flag == false) {
				tmp1 : set of string;
				add(tmp1, genkill.gen);add(tmp1, genkill.kill);
				add(cur_val.out, setClone(tmp1));
			}
		}
		else {
				tmp4 : set of string;
				add(tmp4, genkill.kill);
				add(cur_val.out, setClone(tmp4));
		}
	}
	return cur_val;
};

# user-defined fix point function that is used for analysis termination.
fixp1 := fixp(curr, prev: T1) : bool {
	if (difference1(curr.out, prev.out) == 0)
		return true;	
	return false;
};

#initial phase that initializes output value for each node. initially all variables only alias themselves.
resultPhase := traversal(node: CFGNode) {
	cur_val := getValue(node, analysisPhase);
	mt[node.id] << string(cur_val.out);
};

q_all := visitor {
	before node: CodeRepository -> {
		snapshot := getsnapshot(node, "SOURCE_JAVA_JLS");
		foreach (i: int; def(snapshot[i]))
			visit(snapshot[i]);
		stop;
	}
	before node: Method -> {
			ttime := currentTime();

		cfg = getcfg(node);
		clear(analysisPhase);
		no_fixp = 0;
			t_ttime0 = currentTime() - ttime;
		ttime = currentTime();
		traverse(cfg, TraversalDirection.FORWARD, TraversalKind.SHALLOW_ITERATIVE, initPhase);
		traverse(cfg, TraversalDirection.FORWARD, TraversalKind.HYBRID, analysisPhase, fixp1);
		t_ttime3 = currentTime() - ttime;
		traverse(cfg, TraversalDirection.FORWARD, TraversalKind.SHALLOW_ITERATIVE, resultPhase);
	}
};

visit(p, q_all);
