m: output collection[string][string][int] of int;
mt: output collection[int] of string;
accuracy : output collection of int;
mt1: output collection[string][int] of string;
p: Project = input;

# program analysis output
type Tloop = {start : int, end : int, use : set of string};
type finiteLoop = {start : int, end : int};
# cfg of the current method
cfg: CFG;
pcount := 0;
# current visiting cfg node
cur_cfg_node: CFGNode;
t_ttime0 : int;

genset : set of string;
killset : set of string;
totalTime : int;
time1 : int;
tottime := 0;
t_ttime : int;
t_ttime1 : int;
t_ttime2 : int;
t_ttime3 : int;
no_fixp := 0;
count :=0;
stack_case : stack of int;
project_name : string;
useless_branch : set of int;
endId : int;
invalid : set of int;

# traversal that gets all variable uses in a method
init := traversal(node: CFGNode){
	if(def(node.stmt)) {
		if(node.stmt.kind == StatementKind.RETURN) {
			if(def(node.stmt.expression)) {
				if(node.stmt.expression.kind == ExpressionKind.OP_INC) {
					add(invalid, int(node.id));
				}
			}
		}
	}
};

q_all := visitor {
	before node: Project -> {
		pcount = pcount + 1;
		if(pcount > 601) {
			stop;
		}
	}
	before node: CodeRepository -> {
		snapshot := getsnapshot(node, "SOURCE_JAVA_JLS");
		foreach (i: int; def(snapshot[i]))
			visit(snapshot[i]);
		stop;
	}
	before node: Method -> {
			ttime := currentTime();

			cfg = getcfg(node);
			clear(useless_branch);clear(invalid);
			t_ttime0 = currentTime() - ttime;
			traverse(cfg, TraversalDirection.FORWARD, TraversalKind.HYBRID, init);
			t_ttime3 = currentTime() - ttime;
	}
	after node: Method -> {
		if(len(cfg.nodes)>2) {
				if(cfg.isLoopPresent && len(cfg.nodes)<201) {
					mt[len(cfg.nodes)] << "l,"+string(t_ttime0+t_ttime)+","+string(t_ttime0+t_ttime1)+","+string(t_ttime0+t_ttime2)+","+string(t_ttime0+t_ttime3);
				}
				else if(cfg.isBranchPresent) {
					mt[len(cfg.nodes)] << "b,"+string(t_ttime0+t_ttime)+","+string(t_ttime0+t_ttime1)+","+string(t_ttime0+t_ttime2)+","+string(t_ttime0+t_ttime3);
				}
				else {
					mt[len(cfg.nodes)] << "s,"+string(t_ttime0+t_ttime)+","+string(t_ttime0+t_ttime1)+","+string(t_ttime0+t_ttime2)+","+string(t_ttime0+t_ttime3);
}
				#tottime = tottime + time1;
		}
	}

};

visit(p, q_all);
