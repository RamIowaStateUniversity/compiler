m: output collection[string][int] of string;
mt: output collection[int] of string;
p: Project = input;

# program analysis output
type T= {dom: set of string, dummy : int};
	
# cfg of the current method
cfg: CFG;
pcount := 0;
#set of all cfgnode ids
cfgnode_ids:set of string;
t_ttime0 : int;

method_name : string;

t_ttime : int;
t_ttime1 : int;
t_ttime2 : int;
t_ttime3 : int;
no_fixp := 0;
exitId : int;

# traversal to collect all cfgnode ids
allnode_ids := traversal(node: CFGNode) : string {
	add(cfgnode_ids, string(node.id));
	return string(node.id);
};

# traversal that constructs dominator set of cfg node
cfg_dom := traversal(node: CFGNode): T {
	no_fixp = no_fixp + 1;
	cur_value : T;
	if(node.id==exitId) {
			self_dom:set of string;
			cur_value = {self_dom, 0};
	}
	else
		cur_value = {cfgnode_ids, 0};
	if(def(getValue(node))) {
		cur_val1 := getValue(node);
		cur_value = clone(cur_val1);
	}
	start_dom:set of string;
	add(start_dom, string(node.id));
		preds:=node.successors;
		foreach(i:int;def(preds[i])) {
			pred_value := getValue(preds[i]);
			if(def(pred_value)) {
				cur_value.dom = intersection(cur_value.dom,pred_value.dom);
			}
		}	
	gen_kill := getValue(node, allnode_ids);
if(def(gen_kill)) {
	add(cur_value.dom, gen_kill);
	}
	return cur_value;
};

# traversal that constructs dominator set of cfg node
cfg_dom1 := traversal(node: CFGNode): T {
	no_fixp = no_fixp + 1;
	cur_value : T;
	if(node.id==exitId) {
			self_dom:set of string;
			cur_value = {self_dom, 0};
	}
	else
		cur_value = {setClone(cfgnode_ids), 0};
	if(def(getValue(node))) {
		cur_val1 := getValue(node);
		cur_value = clone(cur_val1);
	}
	start_dom:set of string;
	add(start_dom, string(node.id));
		preds:=node.successors;
		foreach(i:int;def(preds[i])) {
			pred_value := getValue(preds[i]);
			if(def(pred_value)) {
				cur_value.dom = intersection(cur_value.dom,pred_value.dom);
			}
		}	
	gen_kill := getValue(node, allnode_ids);
	if(def(gen_kill)) {
	add(cur_value.dom, gen_kill);
	}
	return cur_value;
};

# traversal that constructs dominator set of cfg node
cfg_dom2 := traversal(node: CFGNode): T {
	#no_fixp = no_fixp + 1;
	cur_value : T;
	if(node.id==exitId) {
			self_dom:set of string;
			cur_value = {self_dom, 0};
	}
	else
		cur_value = {setClone(cfgnode_ids), 0};
	if(def(getValue(node))) {
		cur_val1 := getValue(node);
		cur_value = clone(cur_val1);
	}
	start_dom:set of string;
	add(start_dom, string(node.id));
		preds:=node.successors;
		foreach(i:int;def(preds[i])) {
			pred_value := getValue(preds[i]);
			if(def(pred_value)) {
				cur_value.dom = intersection(cur_value.dom,pred_value.dom);
			}
		}	
	gen_kill := getValue(node, allnode_ids);
	if(def(gen_kill)) {
	add(cur_value.dom, gen_kill);
	}
	return cur_value;
};

# traversal that constructs dominator set of cfg node
cfg_dom3 := traversal(node: CFGNode): T {
	#no_fixp = no_fixp + 1;
	cur_value : T;
	if(node.id==exitId) {
			self_dom:set of string;
			cur_value = {self_dom, 0};
	}
	else
		cur_value = {setClone(cfgnode_ids), 0};
	if(def(getValue(node))) {
		cur_val1 := getValue(node);
		cur_value = clone(cur_val1);
	}
	start_dom:set of string;
	add(start_dom, string(node.id));
		preds:=node.successors;
		foreach(i:int;def(preds[i])) {
			pred_value := getValue(preds[i]);
			if(def(pred_value)) {
				cur_value.dom = intersection(cur_value.dom,pred_value.dom);
			}
		}	
	gen_kill := getValue(node, allnode_ids);
	if(def(gen_kill)) {
	add(cur_value.dom, gen_kill);
	}
	return cur_value;
};

# print results
dom_result := traversal(node: CFGNode) {
	cur_value := getValue(node, cfg_dom);
	m["dfs"][node.id] << string(cur_value.dom);
	cur_value1 := getValue(node, cfg_dom1);
	if(def(cur_value1))
		m["pso"][node.id] << string(cur_value1.dom);
	cur_value2 := getValue(node, cfg_dom2);
	m["wli"][node.id] << string(cur_value2.dom);
	cur_value3 := getValue(node, cfg_dom3);
	if(def(cur_value3))
	m["mix"][node.id] << string(cur_value3.dom);
};

# user-defined fix point function that is used for analysis termination.
fixp1 := fixp(curr, prev: T) : bool {
 	if (difference(curr.dom, prev.dom) == 0)
 		return true;	
 	return false;
};

q_all := visitor {
	before node: Project -> {
		pcount = pcount + 1;
		if(pcount > 601) {
			stop;
		}
	}
	before node: CodeRepository -> {
		snapshot := getsnapshot(node, "SOURCE_JAVA_JLS");
		foreach (i: int; def(snapshot[i]))
			visit(snapshot[i]);
		stop;
	}

	before node: Method -> {
			ttime := currentTime();

		clear(cfg_dom);clear(cfg_dom1);clear(cfg_dom2);clear(cfg_dom3);
		cfg = getcfg(node);
		exitId = len(cfg.nodes) - 1;
		no_fixp = 0;
clear(cfgnode_ids);clear(allnode_ids);
			t_ttime0 = currentTime() - ttime;
		ttime = currentTime();
		traverse(cfg, TraversalDirection.FORWARD, TraversalKind.DFS, allnode_ids);
		traverse(cfg, TraversalDirection.FORWARD, TraversalKind.DFS, cfg_dom, fixp1);
		t_ttime = currentTime() - ttime;
clear(cfgnode_ids);clear(allnode_ids);
		ttime = currentTime();
		traverse(cfg, TraversalDirection.FORWARD, TraversalKind.POSTORDER, allnode_ids);
		traverse(cfg, TraversalDirection.FORWARD, TraversalKind.POSTORDER, cfg_dom1, fixp1);
		t_ttime1 = currentTime() - ttime;
clear(cfgnode_ids);clear(allnode_ids);
		ttime = currentTime();
		traverse(cfg, TraversalDirection.FORWARD, TraversalKind.WORKLIST, allnode_ids);
		traverse(cfg, TraversalDirection.FORWARD, TraversalKind.WORKLIST, cfg_dom2, fixp1);
		t_ttime2 = currentTime() - ttime;
clear(cfgnode_ids);clear(allnode_ids);
		ttime = currentTime();
		traverse(cfg, TraversalDirection.FORWARD, TraversalKind.SHALLOW_ITERATIVE, allnode_ids);
		traverse(cfg, TraversalDirection.FORWARD, TraversalKind.HYBRID, cfg_dom3, fixp1);
		t_ttime3 = currentTime() - ttime;
		#traverse(cfg, TraversalKind.SHALLOW_ITERATIVE, dom_result);
	}
	after node: Method -> {
		if(no_fixp!=0 && len(cfg.nodes)>2) {
				if(cfg.isLoopPresent && len(cfg.nodes)<201) {
					mt[len(cfg.nodes)] << "l,"+string(t_ttime0+t_ttime)+","+string(t_ttime0+t_ttime1)+","+string(t_ttime0+t_ttime2)+","+string(t_ttime0+t_ttime3);
				}
				else if(cfg.isBranchPresent) {
					mt[len(cfg.nodes)] << "b,"+string(t_ttime0+t_ttime)+","+string(t_ttime0+t_ttime1)+","+string(t_ttime0+t_ttime2)+","+string(t_ttime0+t_ttime3);
				}
				else {
					mt[len(cfg.nodes)] << "s,"+string(t_ttime0+t_ttime)+","+string(t_ttime0+t_ttime1)+","+string(t_ttime0+t_ttime2)+","+string(t_ttime0+t_ttime3);
}
				#tottime = tottime + time1;
		}
	}

};

visit(p, q_all);
