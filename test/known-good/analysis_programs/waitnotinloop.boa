m: output collection[string][string][int] of int;
mt: output collection[int] of string;
mt1: output collection[string][int] of string;
p: Project = input;
t_ttime0 : int;

# program analysis output
type Tloop = {start : int, end : int, use : set of string};
# cfg of the current method
cfg: CFG;
pcount := 0;
cur_id : int;
flag := false;
totalTime : int;
time1 : int;
tottime := 0;
t_ttime : int;
t_ttime1 : int;
t_ttime2 : int;
t_ttime3 : int;
no_fixp := 0;
count :=0;
project_name : string;
loops : set of Tloop;
waitnotinloop : set of string;

# traversal that gets all variable uses in a method
init := traversal(node: CFGNode){
	init_set : set of string;
	cur_val : Tloop = {-1, -1, init_set};
	if(node.name == "WHILE" || node.name == "FOR") {
		succs := node.successors;
		foreach(succ:CFGNode=succs) {
			if(succ.id > node.id + 1) {
				cur_val.start= int(node.id);
				cur_val.end= int(succ.id);
				cur_val.use = node.useVariables;
				add(loops, cur_val);
			}		
		}
	}
};

# expression visitor to generate new values
evisitor := visitor {
	before node:Expression -> {
		switch(node.kind) {
			case ExpressionKind.METHODCALL: 
				if(node.method == "wait") {
					flag = false;
					foreach(temp:Tloop=loops) {
						if(cur_id > temp.start && cur_id < temp.end) {
							flag = true;
							break;
						}
					}
					if(!flag) {
						add(waitnotinloop, string(cur_id));
					}
				}
  				break;
			default: break;
		}
	}
};

# traversal that accumulates generated values
track := traversal(node: CFGNode) {
	cur_id = node.id;
	if (def(node.expr)) {
		visit(node.expr, evisitor);
	}
};

q_all := visitor {
	before node: Project -> {
		pcount = pcount + 1;
		if(pcount > 601) {
			stop;
		}
	}
	before node: CodeRepository -> {
		snapshot := getsnapshot(node, "SOURCE_JAVA_JLS");
		foreach (i: int; def(snapshot[i]))
			visit(snapshot[i]);
		stop;
	}
	before node: Method -> {
			ttime := currentTime();

			clear(loops);clear(waitnotinloop);
			cfg = getcfg(node);
			clear(init);clear(track);
			t_ttime0 = currentTime() - ttime;
			ttime = currentTime();
			traverse(cfg, TraversalDirection.FORWARD, TraversalKind.DFS, init);
			traverse(cfg, TraversalDirection.FORWARD, TraversalKind.DFS, track);
			t_ttime = currentTime() - ttime;
			clear(loops);clear(waitnotinloop);clear(init);clear(track);
			ttime = currentTime();
			traverse(cfg, TraversalDirection.FORWARD, TraversalKind.POSTORDER, init);
			traverse(cfg, TraversalDirection.FORWARD, TraversalKind.POSTORDER, track);
			t_ttime1 = currentTime() - ttime;
			clear(loops);clear(waitnotinloop);clear(init);clear(track);
			ttime = currentTime();
			traverse(cfg, TraversalDirection.FORWARD, TraversalKind.WORKLIST, init);
			traverse(cfg, TraversalDirection.FORWARD, TraversalKind.WORKLIST, track);
			t_ttime2 = currentTime() - ttime;
			clear(loops);clear(waitnotinloop);clear(init);clear(track);
			ttime = currentTime();
			traverse(cfg, TraversalDirection.FORWARD, TraversalKind.HYBRID, init);
			traverse(cfg, TraversalDirection.FORWARD, TraversalKind.HYBRID, track);
			t_ttime3 = currentTime() - ttime;

	}
	after node: Method -> {
		if(len(cfg.nodes)>2) {
				if(cfg.isLoopPresent && len(cfg.nodes)<201) {
					mt[len(cfg.nodes)] << "l,"+string(t_ttime0+t_ttime)+","+string(t_ttime0+t_ttime1)+","+string(t_ttime0+t_ttime2)+","+string(t_ttime0+t_ttime3);
				}
				else if(cfg.isBranchPresent) {
					mt[len(cfg.nodes)] << "b,"+string(t_ttime0+t_ttime)+","+string(t_ttime0+t_ttime1)+","+string(t_ttime0+t_ttime2)+","+string(t_ttime0+t_ttime3);
				}
				else {
					mt[len(cfg.nodes)] << "s,"+string(t_ttime0+t_ttime)+","+string(t_ttime0+t_ttime1)+","+string(t_ttime0+t_ttime2)+","+string(t_ttime0+t_ttime3);
}
				#tottime = tottime + time1;
		}
	}

};

visit(p, q_all);
